<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Taming asynchronicity with reactive programming</title>

	<meta name="author" content="Valentin Robert">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/night.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/agate.css">

	<style>
    kbd.keyboard-key {
    	border: 1px solid #090909;
    	border-radius: 20px;
    	background-color: #f9f9f9;
			color: black;
			display: flex;
			flex-direction: column;
			width: 40px;
  	}
		.half-inline {
			width: 48% !important;
		}
  </style>

	<script src="lib/js/html5shiv.js"></script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">

			<section>
				<h1>Taming asynchronicity</h1>
				<h2> with reactive programming</h2>
				<p>
					<small>Created by <a href="http://cs.ucsd.edu/~vrobert">Valentin Robert</a> (<a href="https://github.com/Ptival/learn-from-peers-rxjs">source</a>)</small>
				</p>
			</section>

			<section>
				<h2>Async programming 101</h2>
				<p>cooperative multitasking ⇒ waiting stops everything</p>
				<button id="button-1">Click me for some bad user experience! :(</button>
				<p>Counter: <p id="counter-1">0</p></p>
				<pre><code class="typescript hljs input" data-trim contenteditable>
const sleep = duration => {
  const now = (new Date).getTime();
  while((new Date).getTime() < now + duration) { }
}
let counter = 0;
$("#button-1").off("click");
$("#button-1").on("click", () => {
  sleep(5000);
  $("#counter-1").text(++counter);
});
				</code></pre>
			</section>

			<section>
				<h2>Async programming 101</h2>
				<p>but there are so many reasons to wait!</p>
				<pre><code class="typescript hljs" data-trim contenteditable>
firstAnimation();
// wait until it finishes
secondAnimation();
				</code></pre>
				<pre><code class="typescript hljs" data-trim contenteditable>
const data = retrieveFromTheInternet();
// wait until it is received
doSomethingWith(data);
				</code></pre>
			</section>

			<section>
				<h2>Callbacks</h2>
				<p>Instead of waiting, register a function to be called upon completion</p>
				<div style="display: flex; flex-wrap: wrap;">
					<div class="half-inline">Raw</div><div class="half-inline">Callback</div>
					<pre class="half-inline"><code class="typescript hljs" data-trim contenteditable>
firstAnimation();
// wait until it finishes
secondAnimation();
					</code></pre>
					<pre class="half-inline"><code class="typescript hljs" data-trim contenteditable>
firstAnimation(() => secondAnimation(...));
					</code></pre>
					<pre class="half-inline"><code class="typescript hljs" data-trim contenteditable>
const data = retrieveFromTheInternet();
// wait until it is received
doSomethingWith(data);
					</code></pre>
					<pre class="half-inline"><code class="typescript hljs" data-trim contenteditable>
retrieveDataFromTheInternet(doSomethingWith);
					</code></pre>
				</div>
			</section>

			<section>
				<h2>Callback hell</h2>
				<p>Chaining callbacks can become ugly</p>
				<p>What I meant:</p>
				<pre><code class="typescript hljs" data-trim contenteditable>
const a = getA();
const b = getB(a);
const c = getC(b);
const d = getD();
doSomethingWith(c, d);
				</pre></code>
				<p>What I had to write:</p>
				<pre><code class="typescript hljs" data-trim contenteditable>
getA(a =>
  getB(a, b =>
    getC(b, c =>
      getD(d => doSomethingWith(c, d))
    )
  )
)
				</pre></code>
				</code></pre>
			</section>

			<section>
				<h2>Promises</h2>
				<p>First-class value representing an asynchronous value</p>
				<p>What I meant:</p>
				<pre><code class="typescript hljs" data-trim contenteditable>
const a = getA();
const b = getB(a);
const c = getC(b);
const d = getD();
doSomethingWith(c, d);
				</pre></code>
				<p>What I had to write:</p>
				<pre><code class="typescript hljs" data-trim contenteditable>
const c = getA
  .then(getB)
  .then(getC);
const d = getD();
Promise.all([c, d]).then(cd => doSomething(...cd));
				</pre></code>
				</code></pre>
			</section>

			<section>
				<p><span style="color: lightgreen">Promises</span> are great to deal with:</p>
				<ul>
					<li><span style="color: red">one</span> value</li>
					<li>obtained <span style="color: red">async</span>hronously</li>
					<li>whose acquisition might <span style="color: red">fail</span></li>
				</ul>
			</section>

			<section>
				<p><span style="color: lightgreen">Observables</span> are great to deal with:</p>
				<ul>
					<li><span style="color: red">one, many, or infinitely many</span> values</li>
					<li>obtained <span style="color: red">async</span>hronously</li>
					<li>whose acquisition might <span style="color: red">fail</span></li>
				</ul>
			</section>

			<section>
				<h2>Observable</h2>
				<p>A first-class value to represent a stream of values</p>
				<pre><code class="typescript hljs input" data-trim contenteditable>
const observable = Rx.Observable.fromArray([1, 2, 3]);

observable.subscribe(
  output,                   // what to do when an item is emitted
  output,                   // what to do when the stream fails
  () => output("Complete")  // what to do when the stream completes
);
				</code></pre>
			</section>

			<section>
				<h2>Observable</h2>
				<p>Some observables never fail, or never complete.</p>
				<pre><code class="typescript hljs input" data-trim contenteditable>
Rx.Observable.interval(100)
             .subscribe(output);
			</code></pre>
			</section>

			<section>
				<h2>Example: autocomplete</h2>
				<div class="row-fluid">
        	<label for="wikipedia-input">Wikipedia Search: </label>
        	<input type="text" id="wikipedia-input" style="vertical-align: middle; font-size: 30px; height: 40px" placeholder="Enter Query...">
				</div>
    		<div class="row-fluid">
      		<ul id="wikipedia-output"></ul>
    		</div>
				<pre><code class="typescript hljs input" data-trim contenteditable>
const searchWikipediaPromise = term => $.ajax({
  url: 'http://en.wikipedia.org/w/api.php',
  dataType: 'jsonp',
  data: { action: 'opensearch', format: 'json', search: term }
}).promise();

const nbRetries = 100, delayBetweenRetries = 1000;

const searchWikipedia$ = term =>
  Rx.Observable.defer(() => searchWikipediaPromise(term))
               .retryWhen(e => e.delay(delayBetweenRetries))
               .take(nbRetries);

const $input = $("#wikipedia-input"), $output = $("#wikipedia-output");

Rx.Observable.fromEvent($input, "keyup")
  .map(e => e.target.value)
  .filter(t => t.length > 2)
  .debounce(750)
  .distinctUntilChanged()
  .flatMapLatest(searchWikipedia$)
  .subscribe(
    data => $output.empty()
                   .append(_(data[1]).take(3).map(v => $("&lt;li>").text(v)).value()),
    error => $output.text(`Error: ${error.status} ${error.statusText}`)
  );
				</code></pre>
			</section>

			<section>
				<h2>Example: Konami code</h2>
				<p id="konami" style="display: flex; justify-content: center;">
					<kbd class="keyboard-key nowrap">↑</kbd>
					<kbd class="keyboard-key nowrap">↑</kbd>
					<kbd class="keyboard-key nowrap">↓</kbd>
					<kbd class="keyboard-key nowrap">↓</kbd>
					<kbd class="keyboard-key nowrap">←</kbd>
					<kbd class="keyboard-key nowrap">→</kbd>
					<kbd class="keyboard-key nowrap">←</kbd>
					<kbd class="keyboard-key nowrap">→</kbd>
					<kbd class="keyboard-key nowrap">B</kbd>
					<kbd class="keyboard-key nowrap">A</kbd>
				</p>
				<pre contenteditable="true" id="konami-input">                              Input the Konami code here.</pre>
				<pre><code class="typescript hljs input" data-trim contenteditable>
const konamiArray = [ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65 ];
//                    up  up  dn  dn  lt  rt  lt  rt   b   a
const konami$ = Rx.Observable.fromArray(konamiArray);

$("#konami-input").off("keyup");
const keyWindows$ = Rx.Observable.fromEvent($("#konami-input"), "keyup")
                                 .map(e => e.keyCode)
                                 .startWith(..._.repeat(0, 10))
                                 .windowWithCount(10, 1);

const longestMatch = (w, target) => {
  const slice = _.takeRight(w, target.length);
  return _.isEqual(slice, target) ? target : longestMatch(w, _.initial(target));
};

keyWindows$.flatMap(w => w.toArray())
          .map(w => longestMatch(w, konamiArray))
          .subscribe(a => {
            $("kbd").slice(0, a.length).css("background-color", "green");
            $("kbd").slice(a.length).css("background-color", "red");
          });

keyWindows$.flatMap(w => w.sequenceEqual(konami$))
           .filter(equal => equal)
           .subscribe(() => $("#konami-input").text('KONAMI!'));
			</code></pre>
			</section>

		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>
	<script src="js/jquery.js"></script>
	<script src="js/rx.all.js"></script>
	<script src="js/lodash.js"></script>

	<script>
		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// Optional reveal.js plugins
			dependencies: [{
				src: 'lib/js/classList.js',
				condition: function() {
					return !document.body.classList;
				}
			}, {
				src: 'plugin/markdown/marked.js',
				condition: function() {
					return !!document.querySelector('[data-markdown]');
				}
			}, {
				src: 'plugin/markdown/markdown.js',
				condition: function() {
					return !!document.querySelector('[data-markdown]');
				}
			}, {
				src: 'plugin/highlight/highlight.js',
				async: true,
				callback: function() {
					hljs.initHighlightingOnLoad();
				}
			}, {
				src: 'plugin/zoom-js/zoom.js',
				async: true
			}, {
				src: 'plugin/notes/notes.js',
				async: true
			}, ]
		});

		$(".hljs").attr("spellcheck", false);

		let codeChange = Rx.Observable.fromEvent($("pre"), "keyup");

		let slideChange = Rx.Observable.create(obs => {
			Reveal.addEventListener('slidechanged', event => obs.onNext(event));
		});

		Rx.Observable.merge(codeChange, slideChange).debounce(250).subscribe(() => {
			let currentInput = $(Reveal.getCurrentSlide()).find(".input");
			if (_.isEmpty(currentInput)) {
				return;
			}
			$(Reveal.getCurrentSlide()).find(".output").parent().remove();
			let currentOutput = $("<code>").addClass("output");
			$("<pre>").append(currentOutput).appendTo($(Reveal.getCurrentSlide()));
			//hljs.highlightBlock(currentInput[0]);
			let code = currentInput.text();
			let output = (s) => {
				let currentText = currentOutput.text();
				currentOutput.text(currentText + "// " + s + "\n");
				hljs.highlightBlock(currentOutput[0]);
				Reveal.layout();
			};
			try {
				eval(code);
			} catch (e) {
				output(e);
			}
		});

		let codeUnfocus = Rx.Observable.fromEvent(document, "focusout");

		codeUnfocus.subscribe(() => {
			let currentInput = $(Reveal.getCurrentSlide()).find(".input");
			if (currentInput) {
				hljs.highlightBlock(currentInput[0]);
			}
		});

	</script>

</body>

</html>
